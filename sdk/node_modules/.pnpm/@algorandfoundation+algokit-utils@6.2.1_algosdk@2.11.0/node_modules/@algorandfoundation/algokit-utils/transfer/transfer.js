'use strict';

var algosdk = require('algosdk');
var amount = require('../amount.js');
var config = require('../config.js');
var transaction = require('../transaction/transaction.js');
var types_accountManager = require('../types/account-manager.js');
var types_clientManager = require('../types/client-manager.js');
var types_dispenserClient = require('../types/dispenser-client.js');
var util = require('../util.js');
var transferAlgos = require('./transfer-algos.js');

async function fundUsingDispenserApi(dispenserClient, addressToFund, fundAmount) {
    const response = await dispenserClient.fund(addressToFund, fundAmount);
    return { transactionId: response.txId, amount: response.amount };
}
async function fundUsingTransfer({ algod, addressToFund, funding, fundAmount, transactionParams, sendParams, note, kmd, }) {
    if (funding.fundingSource instanceof types_dispenserClient.TestNetDispenserApiClient) {
        throw new Error('Dispenser API client is not supported in this context.');
    }
    const from = funding.fundingSource ?? (await new types_accountManager.AccountManager(new types_clientManager.ClientManager({ algod, kmd })).dispenserFromEnvironment());
    const amount$1 = amount.microAlgos(Math.max(fundAmount, funding.minFundingIncrement?.microAlgos ?? 0));
    const response = await transferAlgos.transferAlgos({
        from,
        to: addressToFund,
        note: note ?? 'Funding account to meet minimum requirement',
        amount: amount$1,
        transactionParams: transactionParams,
        lease: funding.lease,
        ...sendParams,
    }, algod);
    return {
        transactionId: response.transaction.txID(),
        amount: Number(response.transaction.amount),
    };
}
/**
 * Funds a given account using a funding source such that it has a certain amount of algos free to spend (accounting for ALGOs locked in minimum balance requirement).
 *
 * https://developer.algorand.org/docs/get-details/accounts/#minimum-balance
 *
 * @param funding The funding configuration of type `EnsureFundedParams`, including the account to fund, minimum spending balance, and optional parameters. If you set `useDispenserApi` to true, you must also set `ALGOKIT_DISPENSER_ACCESS_TOKEN` in your environment variables.
 * @param algod An instance of the Algodv2 client.
 * @param kmd An optional instance of the Kmd client.
 * @returns
 * - `EnsureFundedReturnType` if funds were transferred.
 * - `undefined` if no funds were needed.
 */
async function ensureFunded(funding, algod, kmd) {
    const { accountToFund, fundingSource, minSpendingBalance, minFundingIncrement, transactionParams, note, ...sendParams } = funding;
    const addressToFund = typeof accountToFund === 'string' ? accountToFund : transaction.getSenderAddress(accountToFund);
    const accountInfo = await algod.accountInformation(addressToFund).do();
    const balance = Number(accountInfo.amount);
    const minimumBalanceRequirement = amount.microAlgos(Number(accountInfo['min-balance']));
    const currentSpendingBalance = amount.microAlgos(balance - minimumBalanceRequirement.microAlgos);
    const fundAmount = util.calculateFundAmount(minSpendingBalance.microAlgos, currentSpendingBalance.microAlgos, minFundingIncrement?.microAlgos ?? 0);
    if (fundAmount !== null) {
        if ((await new types_clientManager.ClientManager({ algod }).isTestNet()) && fundingSource instanceof types_dispenserClient.TestNetDispenserApiClient) {
            return await fundUsingDispenserApi(fundingSource, addressToFund, fundAmount);
        }
        else {
            return await fundUsingTransfer({
                algod,
                addressToFund,
                funding,
                fundAmount,
                transactionParams,
                sendParams,
                note,
                kmd,
            });
        }
    }
    return undefined;
}
/**
 * Transfer asset between two accounts.
 * @param transfer The transfer definition
 * @param algod An algod client
 * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)
 *
 * @example Usage example
 * ```typescript
 * await algokit.transferAsset({ from, to, assetId, amount }, algod)
 * ```
 */
async function transferAsset(transfer, algod) {
    const { from, to, assetId, amount, transactionParams, clawbackFrom, note, lease, ...sendParams } = transfer;
    const transaction$1 = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: transaction.getSenderAddress(from),
        to: transaction.getSenderAddress(to),
        closeRemainderTo: undefined,
        revocationTarget: clawbackFrom ? transaction.getSenderAddress(clawbackFrom) : undefined,
        amount: amount,
        note: transaction.encodeTransactionNote(note),
        assetIndex: assetId,
        suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
        rekeyTo: undefined,
    });
    const encodedLease = transaction.encodeLease(lease);
    if (encodedLease) {
        transaction$1.addLease(encodedLease);
    }
    if (!sendParams.skipSending) {
        config.Config.getLogger(sendParams.suppressLog).debug(`Transferring ASA (${assetId}) of amount ${amount} from ${transaction.getSenderAddress(from)} to ${transaction.getSenderAddress(to)}`);
    }
    return transaction.sendTransaction({ transaction: transaction$1, from, sendParams }, algod);
}
/**
 * Rekey an account to a new address.
 *
 * **Note:** Please be careful with this function and be sure to read the [official rekey guidance](https://developer.algorand.org/docs/get-details/accounts/rekey/).
 *
 * @param rekey The rekey definition
 * @param algod An algod client
 * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)
 *
 * @example Usage example
 * ```typescript
 * await algokit.rekeyAccount({ from, rekeyTo }, algod)
 * ```
 */
async function rekeyAccount(rekey, algod) {
    const { from, rekeyTo, note, transactionParams, lease, ...sendParams } = rekey;
    const transaction$1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
        from: transaction.getSenderAddress(from),
        to: transaction.getSenderAddress(from),
        rekeyTo: transaction.getSenderAddress(rekeyTo),
        amount: 0,
        note: transaction.encodeTransactionNote(note),
        suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
        closeRemainderTo: undefined,
    });
    const encodedLease = transaction.encodeLease(lease);
    if (encodedLease) {
        transaction$1.addLease(encodedLease);
    }
    if (!sendParams.skipSending) {
        config.Config.getLogger(sendParams.suppressLog).debug(`Rekeying ${transaction.getSenderAddress(from)} to ${transaction.getSenderAddress(rekeyTo)}`);
    }
    return transaction.sendTransaction({ transaction: transaction$1, from, sendParams }, algod);
}

exports.ensureFunded = ensureFunded;
exports.rekeyAccount = rekeyAccount;
exports.transferAsset = transferAsset;
//# sourceMappingURL=transfer.js.map
