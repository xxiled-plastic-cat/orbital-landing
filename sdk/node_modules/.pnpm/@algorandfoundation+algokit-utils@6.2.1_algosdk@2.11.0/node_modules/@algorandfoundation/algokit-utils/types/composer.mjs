import algosdk from 'algosdk';
import { encodeLease, encodeTransactionNote, sendAtomicTransactionComposer } from '../transaction/transaction.mjs';
import { ClientManager } from './client-manager.mjs';

var isTransactionWithSigner = algosdk.isTransactionWithSigner;
var encodeAddress = algosdk.encodeAddress;
/** AlgoKit Composer helps you compose and execute transactions as a transaction group.
 *
 * Note: this class is a new Beta feature and may be subject to change.
 *
 * @beta
 */
class AlgokitComposer {
    /**
     * Create an `AlgoKitComposer`.
     * @param params The configuration for this composer
     */
    constructor(params) {
        /** The ATC used to compose the group */
        this.atc = new algosdk.AtomicTransactionComposer();
        /** Map of txid to ABI method */
        this.txnMethodMap = new Map();
        /** Transactions that have not yet been composed */
        this.txns = [];
        /** The default transaction validity window */
        this.defaultValidityWindow = 10;
        /** Whether the validity window was explicitly set on construction */
        this.defaultValidityWindowIsExplicit = false;
        this.algod = params.algod;
        const defaultGetSuggestedParams = () => params.algod.getTransactionParams().do();
        this.getSuggestedParams = params.getSuggestedParams ?? defaultGetSuggestedParams;
        this.getSigner = params.getSigner;
        this.defaultValidityWindow = params.defaultValidityWindow ?? this.defaultValidityWindow;
        this.defaultValidityWindowIsExplicit = params.defaultValidityWindow !== undefined;
    }
    /**
     * Add a payment transaction to the transaction group.
     * @param params The payment transaction parameters
     * @returns The composer so you can chain method calls
     */
    addPayment(params) {
        this.txns.push({ ...params, type: 'pay' });
        return this;
    }
    /**
     * Add an asset create transaction to the transaction group.
     * @param params The asset create transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetCreate(params) {
        this.txns.push({ ...params, type: 'assetCreate' });
        return this;
    }
    /**
     * Add an asset config transaction to the transaction group.
     * @param params The asset config transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetConfig(params) {
        this.txns.push({ ...params, type: 'assetConfig' });
        return this;
    }
    /**
     * Add an asset freeze transaction to the transaction group.
     * @param params The asset freeze transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetFreeze(params) {
        this.txns.push({ ...params, type: 'assetFreeze' });
        return this;
    }
    /**
     * Add an asset destroy transaction to the transaction group.
     * @param params The asset destroy transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetDestroy(params) {
        this.txns.push({ ...params, type: 'assetDestroy' });
        return this;
    }
    /**
     * Add an asset transfer transaction to the transaction group.
     * @param params The asset transfer transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetTransfer(params) {
        this.txns.push({ ...params, type: 'assetTransfer' });
        return this;
    }
    /**
     * Add an asset opt-in transaction to the transaction group.
     * @param params The asset opt-in transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetOptIn(params) {
        this.txns.push({ ...params, type: 'assetOptIn' });
        return this;
    }
    /**
     * Add an application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCall(params) {
        this.txns.push({ ...params, type: 'appCall' });
        return this;
    }
    /**
     * Add an ABI method application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addMethodCall(params) {
        this.txns.push({ ...params, type: 'methodCall' });
        return this;
    }
    /**
     * Add an online key registration transaction to the transaction group.
     * @param params The online key registration transaction parameters
     * @returns The composer so you can chain method calls
     */
    addOnlineKeyRegistration(params) {
        this.txns.push({ ...params, type: 'keyReg' });
        return this;
    }
    /**
     * Add the transactions within an `AtomicTransactionComposer` to the transaction group.
     * @param atc The `AtomicTransactionComposer` to build transactions from and add to the group
     * @returns The composer so you can chain method calls
     */
    addAtc(atc) {
        this.txns.push({ atc, type: 'atc' });
        return this;
    }
    buildAtc(atc) {
        const group = atc.buildGroup();
        const txnWithSigners = group.map((ts) => {
            ts.txn.group = undefined;
            return ts;
        });
        const method = atc['methodCalls'].get(group.length - 1);
        if (method)
            this.txnMethodMap.set(txnWithSigners.at(-1).txn.txID(), method);
        return txnWithSigners;
    }
    commonTxnBuildStep(params, txn, suggestedParams) {
        if (params.lease)
            txn.addLease(encodeLease(params.lease));
        if (params.rekeyTo)
            txn.addRekey(params.rekeyTo);
        if (params.note)
            txn.note = encodeTransactionNote(params.note);
        if (params.firstValidRound) {
            txn.firstRound = Number(params.firstValidRound);
        }
        if (params.lastValidRound) {
            txn.lastRound = Number(params.lastValidRound);
        }
        else {
            // If the validity window isn't set in this transaction or by default and we are pointing at
            //  LocalNet set a bigger window to avoid dead transactions
            const window = params.validityWindow ??
                (!this.defaultValidityWindowIsExplicit && ClientManager.genesisIdIsLocalNet(suggestedParams.genesisID)
                    ? 1000
                    : this.defaultValidityWindow);
            txn.lastRound = txn.firstRound + window;
        }
        if (params.staticFee !== undefined && params.extraFee !== undefined) {
            throw Error('Cannot set both staticFee and extraFee');
        }
        if (params.staticFee !== undefined) {
            txn.fee = params.staticFee.microAlgos;
        }
        else {
            txn.fee = txn.estimateSize() * suggestedParams.fee || algosdk.ALGORAND_MIN_TX_FEE;
            if (params.extraFee)
                txn.fee += params.extraFee.microAlgos;
        }
        txn.flatFee = true;
        if (params.maxFee !== undefined && txn.fee > params.maxFee.microAlgos) {
            throw Error(`Transaction fee ${txn.fee} is greater than maxFee ${params.maxFee}`);
        }
        return txn;
    }
    async buildMethodCall(params, suggestedParams) {
        const methodArgs = [];
        const isAbiValue = (x) => {
            if (Array.isArray(x))
                return x.length == 0 || x.every(isAbiValue);
            return ['boolean', 'number', 'bigint', 'string', 'Uint8Array'].includes(typeof x);
        };
        for (const arg of params.args ?? []) {
            if (isAbiValue(arg)) {
                methodArgs.push(arg);
                continue;
            }
            if (isTransactionWithSigner(arg)) {
                methodArgs.push(arg);
                continue;
            }
            if ('method' in arg) {
                const tempTxnWithSigners = await this.buildMethodCall(arg, suggestedParams);
                methodArgs.push(...tempTxnWithSigners);
                continue;
            }
            const txn = await arg;
            methodArgs.push({
                txn,
                signer: params.signer
                    ? 'signer' in params.signer
                        ? params.signer.signer
                        : params.signer
                    : this.getSigner(encodeAddress(txn.from.publicKey)),
            });
        }
        const methodAtc = new algosdk.AtomicTransactionComposer();
        const appID = Number(params.appId || 0);
        methodAtc.addMethodCall({
            appID,
            sender: params.sender,
            suggestedParams,
            onComplete: params.onComplete,
            appAccounts: params.accountReferences,
            appForeignApps: params.appReferences?.map((x) => Number(x)),
            appForeignAssets: params.assetReferences?.map((x) => Number(x)),
            approvalProgram: params.approvalProgram,
            clearProgram: params.clearProgram,
            extraPages: params.extraPages,
            numLocalInts: params.schema?.localUints || (appID === 0 ? 0 : undefined),
            numLocalByteSlices: params.schema?.localByteSlices || (appID === 0 ? 0 : undefined),
            numGlobalInts: params.schema?.globalUints || (appID === 0 ? 0 : undefined),
            numGlobalByteSlices: params.schema?.globalByteSlices || (appID === 0 ? 0 : undefined),
            method: params.method,
            signer: params.signer ? ('signer' in params.signer ? params.signer.signer : params.signer) : this.getSigner(params.sender),
            methodArgs: methodArgs,
            // note, lease, and rekeyTo are set in the common build step
            note: undefined,
            lease: undefined,
            rekeyTo: undefined,
        });
        // Run the actual method call txn through the common build step to set fees and validity rounds
        const group = methodAtc.buildGroup();
        const methodIdx = group.length - 1;
        group[methodIdx].txn = this.commonTxnBuildStep(params, group[methodIdx].txn, suggestedParams);
        return this.buildAtc(methodAtc);
    }
    buildPayment(params, suggestedParams) {
        const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
            from: params.sender,
            to: params.receiver,
            amount: params.amount.microAlgos,
            closeRemainderTo: params.closeRemainderTo,
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetCreate(params, suggestedParams) {
        const txn = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({
            from: params.sender,
            total: params.total,
            decimals: params.decimals ?? 0,
            assetName: params.assetName,
            unitName: params.unitName,
            assetURL: params.url,
            defaultFrozen: params.defaultFrozen ?? false,
            assetMetadataHash: params.metadataHash,
            manager: params.manager,
            reserve: params.reserve,
            freeze: params.freeze,
            clawback: params.clawback,
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetConfig(params, suggestedParams) {
        const txn = algosdk.makeAssetConfigTxnWithSuggestedParamsFromObject({
            from: params.sender,
            assetIndex: Number(params.assetId),
            suggestedParams,
            manager: params.manager,
            reserve: params.reserve,
            freeze: params.freeze,
            clawback: params.clawback,
            strictEmptyAddressChecking: false,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetDestroy(params, suggestedParams) {
        const txn = algosdk.makeAssetDestroyTxnWithSuggestedParamsFromObject({
            from: params.sender,
            assetIndex: Number(params.assetId),
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetFreeze(params, suggestedParams) {
        const txn = algosdk.makeAssetFreezeTxnWithSuggestedParamsFromObject({
            from: params.sender,
            assetIndex: Number(params.assetId),
            freezeTarget: params.account,
            freezeState: params.frozen,
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetTransfer(params, suggestedParams) {
        const txn = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({
            from: params.sender,
            to: params.receiver,
            assetIndex: Number(params.assetId),
            amount: params.amount,
            suggestedParams,
            closeRemainderTo: params.closeAssetTo,
            revocationTarget: params.clawbackTarget,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAppCall(params, suggestedParams) {
        const sdkParams = {
            from: params.sender,
            suggestedParams,
            onComplete: params.onComplete,
            approvalProgram: params.approvalProgram,
            clearProgram: params.clearProgram,
            appArgs: params.args,
            accounts: params.accountReferences,
            foreignApps: params.appReferences?.map((x) => Number(x)),
            foreignAssets: params.assetReferences?.map((x) => Number(x)),
            extraPages: params.extraPages,
            numLocalInts: params.schema?.localUints || 0,
            numLocalByteSlices: params.schema?.localByteSlices || 0,
            numGlobalInts: params.schema?.globalUints || 0,
            numGlobalByteSlices: params.schema?.globalByteSlices || 0,
        };
        let txn;
        const onComplete = params.onComplete || algosdk.OnApplicationComplete.NoOpOC;
        if (!params.appId) {
            if (params.approvalProgram === undefined || params.clearProgram === undefined) {
                throw new Error('approvalProgram and clearProgram are required for application creation');
            }
            txn = algosdk.makeApplicationCreateTxnFromObject({
                ...sdkParams,
                onComplete,
                approvalProgram: params.approvalProgram,
                clearProgram: params.clearProgram,
            });
        }
        txn = algosdk.makeApplicationCallTxnFromObject({ ...sdkParams, onComplete, appIndex: Number(params.appId || 0) });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildKeyReg(params, suggestedParams) {
        const txn = algosdk.makeKeyRegistrationTxnWithSuggestedParams(params.sender, undefined, params.voteKey, params.selectionKey, Number(params.voteFirst), Number(params.voteLast), Number(params.voteKeyDilution), suggestedParams, undefined, false, params.stateProofKey);
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    async buildTxn(txn, suggestedParams) {
        if (txn.type === 'txnWithSigner') {
            return [txn];
        }
        if (txn.type === 'atc') {
            return this.buildAtc(txn.atc);
        }
        if (txn.type === 'methodCall') {
            return await this.buildMethodCall(txn, suggestedParams);
        }
        const signer = txn.signer ? ('signer' in txn.signer ? txn.signer.signer : txn.signer) : this.getSigner(txn.sender);
        switch (txn.type) {
            case 'pay': {
                const payment = this.buildPayment(txn, suggestedParams);
                return [{ txn: payment, signer }];
            }
            case 'assetCreate': {
                const assetCreate = this.buildAssetCreate(txn, suggestedParams);
                return [{ txn: assetCreate, signer }];
            }
            case 'appCall': {
                const appCall = this.buildAppCall(txn, suggestedParams);
                return [{ txn: appCall, signer }];
            }
            case 'assetConfig': {
                const assetConfig = this.buildAssetConfig(txn, suggestedParams);
                return [{ txn: assetConfig, signer }];
            }
            case 'assetDestroy': {
                const assetDestroy = this.buildAssetDestroy(txn, suggestedParams);
                return [{ txn: assetDestroy, signer }];
            }
            case 'assetFreeze': {
                const assetFreeze = this.buildAssetFreeze(txn, suggestedParams);
                return [{ txn: assetFreeze, signer }];
            }
            case 'assetTransfer': {
                const assetTransfer = this.buildAssetTransfer(txn, suggestedParams);
                return [{ txn: assetTransfer, signer }];
            }
            case 'assetOptIn': {
                const assetTransfer = this.buildAssetTransfer({ ...txn, receiver: txn.sender, amount: 0n }, suggestedParams);
                return [{ txn: assetTransfer, signer }];
            }
            case 'keyReg': {
                const keyReg = this.buildKeyReg(txn, suggestedParams);
                return [{ txn: keyReg, signer }];
            }
            default:
                throw Error(`Unsupported txn type`);
        }
    }
    /**
     * Compose all of the transactions in a single atomic transaction group and an atomic transaction composer.
     *
     * You can then use the transactions standalone, or use the composer to execute or simulate the transactions.
     * @returns The built atomic transaction composer and the transactions
     */
    async build() {
        if (this.atc.getStatus() === algosdk.AtomicTransactionComposerStatus.BUILDING) {
            const suggestedParams = await this.getSuggestedParams();
            const txnWithSigners = [];
            for (const txn of this.txns) {
                txnWithSigners.push(...(await this.buildTxn(txn, suggestedParams)));
            }
            txnWithSigners.forEach((ts) => {
                this.atc.addTransaction(ts);
            });
            const methodCalls = new Map();
            txnWithSigners.forEach((ts, idx) => {
                const method = this.txnMethodMap.get(ts.txn.txID());
                if (method)
                    methodCalls.set(idx, method);
            });
            this.atc['methodCalls'] = methodCalls;
        }
        return { atc: this.atc, transactions: this.atc.buildGroup() };
    }
    /**
     * Rebuild the group, discarding any previously built transactions.
     * This will potentially cause new signers and suggested params to be used if the callbacks return a new value compared to the first build.
     * @returns The newly built atomic transaction composer and the transactions
     */
    async rebuild() {
        this.atc = new algosdk.AtomicTransactionComposer();
        return await this.build();
    }
    /**
     * Compose the atomic transaction group and send it to the network
     * @param params The parameters to control execution with
     * @returns The execution result
     */
    async execute(params) {
        const group = (await this.build()).transactions;
        let waitRounds = params?.maxRoundsToWaitForConfirmation;
        if (waitRounds === undefined) {
            const lastRound = group.reduce((max, txn) => Math.max(txn.txn.lastRound, max), 0);
            const { firstRound } = await this.getSuggestedParams();
            waitRounds = lastRound - firstRound + 1;
        }
        return await sendAtomicTransactionComposer({
            atc: this.atc,
            sendParams: { suppressLog: params?.suppressLog, maxRoundsToWaitForConfirmation: waitRounds },
        }, this.algod);
    }
}

export { AlgokitComposer as default };
//# sourceMappingURL=composer.mjs.map
