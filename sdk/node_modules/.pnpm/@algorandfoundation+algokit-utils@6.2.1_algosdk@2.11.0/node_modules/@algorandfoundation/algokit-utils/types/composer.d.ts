import algosdk from 'algosdk';
import { TransactionSignerAccount } from './account';
import { AlgoAmount } from './amount';
import { SendAtomicTransactionComposerResults } from './transaction';
import Transaction = algosdk.Transaction;
import TransactionWithSigner = algosdk.TransactionWithSigner;
/** Common parameters for defining a transaction. */
export type CommonTransactionParams = {
    /** The address sending the transaction */
    sender: string;
    /** The function used to sign transactions */
    signer?: algosdk.TransactionSigner | TransactionSignerAccount;
    /** Change the signing key of the sender to the given address */
    rekeyTo?: string;
    /** Note to attach to the transaction*/
    note?: Uint8Array | string;
    /** Prevent multiple transactions with the same lease being included within the validity window */
    lease?: Uint8Array | string;
    /** The transaction fee. In most cases you want to use `extraFee` unless setting the fee to 0 to be covered by another transaction */
    staticFee?: AlgoAmount;
    /** The fee to pay IN ADDITION to the suggested fee. Useful for covering inner transaction fees */
    extraFee?: AlgoAmount;
    /** Throw an error if the fee for the transaction is more than this amount */
    maxFee?: AlgoAmount;
    /** How many rounds the transaction should be valid for */
    validityWindow?: number;
    /**
     * Set the first round this transaction is valid.
     * If left undefined, the value from algod will be used.
     * Only set this when you intentionally want this to be some time in the future
     */
    firstValidRound?: bigint;
    /** The last round this transaction is valid. It is recommended to use validityWindow instead */
    lastValidRound?: bigint;
};
/** Parameters to define a payment transaction. */
export type PaymentParams = CommonTransactionParams & {
    /** That account that will receive the ALGO */
    receiver: string;
    /** Amount to send */
    amount: AlgoAmount;
    /** If given, close the sender account and send the remaining balance to this address */
    closeRemainderTo?: string;
};
/** Parameters to define an asset create transaction. */
export type AssetCreateParams = CommonTransactionParams & {
    /** The total amount of the smallest divisible unit to create */
    total: bigint;
    /** The amount of decimal places the asset should have */
    decimals?: number;
    /** Whether the asset is frozen by default in the creator address */
    defaultFrozen?: boolean;
    /** The address that can change the manager, reserve, clawback, and freeze addresses. There will permanently be no manager if undefined or an empty string */
    manager?: string;
    /** The address that holds the uncirculated supply */
    reserve?: string;
    /** The address that can freeze the asset in any account. Freezing will be permanently disabled if undefined or an empty string. */
    freeze?: string;
    /** The address that can clawback the asset from any account. Clawback will be permanently disabled if undefined or an empty string. */
    clawback?: string;
    /** The short ticker name for the asset */
    unitName?: string;
    /** The full name of the asset */
    assetName?: string;
    /** The metadata URL for the asset */
    url?: string;
    /** Hash of the metadata contained in the metadata URL */
    metadataHash?: Uint8Array;
};
/** Parameters to define an asset config transaction. */
export type AssetConfigParams = CommonTransactionParams & {
    /** ID of the asset */
    assetId: bigint;
    /** The address that can change the manager, reserve, clawback, and freeze addresses. There will permanently be no manager if undefined or an empty string */
    manager?: string;
    /** The address that holds the uncirculated supply */
    reserve?: string;
    /** The address that can freeze the asset in any account. Freezing will be permanently disabled if undefined or an empty string. */
    freeze?: string;
    /** The address that can clawback the asset from any account. Clawback will be permanently disabled if undefined or an empty string. */
    clawback?: string;
};
/** Parameters to define an asset freeze transaction. */
export type AssetFreezeParams = CommonTransactionParams & {
    /** The ID of the asset */
    assetId: bigint;
    /** The account to freeze or unfreeze */
    account: string;
    /** Whether the assets in the account should be frozen */
    frozen: boolean;
};
/** Parameters to define an asset destroy transaction. */
export type AssetDestroyParams = CommonTransactionParams & {
    /** ID of the asset */
    assetId: bigint;
};
/** Parameters to define an asset transfer transaction. */
export type AssetTransferParams = CommonTransactionParams & {
    /** ID of the asset */
    assetId: bigint;
    /** Amount of the asset to transfer (smallest divisible unit) */
    amount: bigint;
    /** The account to send the asset to */
    receiver: string;
    /** The account to take the asset from */
    clawbackTarget?: string;
    /** The account to close the asset to */
    closeAssetTo?: string;
};
/** Parameters to define an asset opt-in transaction. */
export type AssetOptInParams = CommonTransactionParams & {
    /** ID of the asset */
    assetId: bigint;
};
/** Parameters to define an online key registration transaction. */
export type OnlineKeyRegistrationParams = CommonTransactionParams & {
    /** The root participation public key */
    voteKey: Uint8Array;
    /** The VRF public key */
    selectionKey: Uint8Array;
    /** The first round that the participation key is valid. Not to be confused with the `firstValid` round of the keyreg transaction */
    voteFirst: bigint;
    /** The last round that the participation key is valid. Not to be confused with the `lastValid` round of the keyreg transaction */
    voteLast: bigint;
    /** This is the dilution for the 2-level participation key. It determines the interval (number of rounds) for generating new ephemeral keys */
    voteKeyDilution: bigint;
    /** The 64 byte state proof public key commitment */
    stateProofKey?: Uint8Array;
};
/** Parameters to define an application call transaction. */
export type AppCallParams = CommonTransactionParams & {
    /** The [OnComplete](https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#oncomplete) */
    onComplete?: algosdk.OnApplicationComplete;
    /** ID of the application */
    appId?: bigint;
    /** The program to execute for all OnCompletes other than ClearState */
    approvalProgram?: Uint8Array;
    /** The program to execute for ClearState OnComplete */
    clearProgram?: Uint8Array;
    /** The state schema for the app. This is immutable. */
    schema?: {
        /** The number of integers saved in global state */
        globalUints: number;
        /** The number of byte slices saved in global state */
        globalByteSlices: number;
        /** The number of integers saved in local state */
        localUints: number;
        /** The number of byte slices saved in local state */
        localByteSlices: number;
    };
    /** Application arguments */
    args?: Uint8Array[];
    /** Account references */
    accountReferences?: string[];
    /** App references */
    appReferences?: bigint[];
    /** Asset references */
    assetReferences?: bigint[];
    /** Number of extra pages required for the programs */
    extraPages?: number;
    /** Box references */
    boxReferences?: algosdk.BoxReference[];
};
/** Parameters to define an ABI method application call transaction. */
export type MethodCallParams = CommonTransactionParams & Omit<AppCallParams, 'args'> & {
    /** ID of the application */
    appId: bigint;
    /** The ABI method to call */
    method: algosdk.ABIMethod;
    /** Arguments to the ABI method, either:
     * * An ABI value
     * * A transaction with explicit signer
     * * A transaction (where the signer will be automatically assigned)
     * * An unawaited transaction (e.g. from algorand.transactions.transactionType())
     * * Another method call (via method call params object)
     */
    args?: (algosdk.ABIValue | TransactionWithSigner | Transaction | Promise<Transaction> | MethodCallParams)[];
};
/** Parameters to configure transaction execution. */
export interface ExecuteParams {
    /** The number of rounds to wait for confirmation. By default until the latest lastValid has past. */
    maxRoundsToWaitForConfirmation?: number;
    /** Whether to suppress log messages from transaction send, default: do not suppress */
    suppressLog?: boolean;
}
/** Parameters to create an `AlgokitComposer`. */
export type AlgokitComposerParams = {
    /** The algod client to use to get suggestedParams and send the transaction group */
    algod: algosdk.Algodv2;
    /** The function used to get the TransactionSigner for a given address */
    getSigner: (address: string) => algosdk.TransactionSigner;
    /** The method used to get SuggestedParams for transactions in the group */
    getSuggestedParams?: () => Promise<algosdk.SuggestedParams>;
    /** How many rounds a transaction should be valid for by default; if not specified
     * then will be 10 rounds (or 1000 rounds if issuing transactions to LocalNet).
     */
    defaultValidityWindow?: number;
};
/** AlgoKit Composer helps you compose and execute transactions as a transaction group.
 *
 * Note: this class is a new Beta feature and may be subject to change.
 *
 * @beta
 */
export default class AlgokitComposer {
    /** The ATC used to compose the group */
    private atc;
    /** Map of txid to ABI method */
    private txnMethodMap;
    /** Transactions that have not yet been composed */
    private txns;
    /** The algod client used by the composer. */
    private algod;
    /** An async function that will return suggestedParams. */
    private getSuggestedParams;
    /** A function that takes in an address and return a signer function for that address. */
    private getSigner;
    /** The default transaction validity window */
    private defaultValidityWindow;
    /** Whether the validity window was explicitly set on construction */
    private defaultValidityWindowIsExplicit;
    /**
     * Create an `AlgoKitComposer`.
     * @param params The configuration for this composer
     */
    constructor(params: AlgokitComposerParams);
    /**
     * Add a payment transaction to the transaction group.
     * @param params The payment transaction parameters
     * @returns The composer so you can chain method calls
     */
    addPayment(params: PaymentParams): AlgokitComposer;
    /**
     * Add an asset create transaction to the transaction group.
     * @param params The asset create transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetCreate(params: AssetCreateParams): AlgokitComposer;
    /**
     * Add an asset config transaction to the transaction group.
     * @param params The asset config transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetConfig(params: AssetConfigParams): AlgokitComposer;
    /**
     * Add an asset freeze transaction to the transaction group.
     * @param params The asset freeze transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetFreeze(params: AssetFreezeParams): AlgokitComposer;
    /**
     * Add an asset destroy transaction to the transaction group.
     * @param params The asset destroy transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetDestroy(params: AssetDestroyParams): AlgokitComposer;
    /**
     * Add an asset transfer transaction to the transaction group.
     * @param params The asset transfer transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetTransfer(params: AssetTransferParams): AlgokitComposer;
    /**
     * Add an asset opt-in transaction to the transaction group.
     * @param params The asset opt-in transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetOptIn(params: AssetOptInParams): AlgokitComposer;
    /**
     * Add an application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCall(params: AppCallParams): AlgokitComposer;
    /**
     * Add an ABI method application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addMethodCall(params: MethodCallParams): this;
    /**
     * Add an online key registration transaction to the transaction group.
     * @param params The online key registration transaction parameters
     * @returns The composer so you can chain method calls
     */
    addOnlineKeyRegistration(params: OnlineKeyRegistrationParams): AlgokitComposer;
    /**
     * Add the transactions within an `AtomicTransactionComposer` to the transaction group.
     * @param atc The `AtomicTransactionComposer` to build transactions from and add to the group
     * @returns The composer so you can chain method calls
     */
    addAtc(atc: algosdk.AtomicTransactionComposer): AlgokitComposer;
    private buildAtc;
    private commonTxnBuildStep;
    private buildMethodCall;
    private buildPayment;
    private buildAssetCreate;
    private buildAssetConfig;
    private buildAssetDestroy;
    private buildAssetFreeze;
    private buildAssetTransfer;
    private buildAppCall;
    private buildKeyReg;
    private buildTxn;
    /**
     * Compose all of the transactions in a single atomic transaction group and an atomic transaction composer.
     *
     * You can then use the transactions standalone, or use the composer to execute or simulate the transactions.
     * @returns The built atomic transaction composer and the transactions
     */
    build(): Promise<{
        atc: algosdk.AtomicTransactionComposer;
        transactions: algosdk.TransactionWithSigner[];
    }>;
    /**
     * Rebuild the group, discarding any previously built transactions.
     * This will potentially cause new signers and suggested params to be used if the callbacks return a new value compared to the first build.
     * @returns The newly built atomic transaction composer and the transactions
     */
    rebuild(): Promise<{
        atc: algosdk.AtomicTransactionComposer;
        transactions: algosdk.TransactionWithSigner[];
    }>;
    /**
     * Compose the atomic transaction group and send it to the network
     * @param params The parameters to control execution with
     * @returns The execution result
     */
    execute(params?: ExecuteParams): Promise<SendAtomicTransactionComposerResults>;
}
//# sourceMappingURL=composer.d.ts.map