'use strict';

var algosdk = require('algosdk');
var config = require('./config.js');
var transaction = require('./transaction/transaction.js');

var ValidationType;
(function (ValidationType) {
    ValidationType[ValidationType["OptIn"] = 0] = "OptIn";
    ValidationType[ValidationType["OptOut"] = 1] = "OptOut";
})(ValidationType || (ValidationType = {}));
function* chunks(arr, n) {
    for (let i = 0; i < arr.length; i += n)
        yield arr.slice(i, i + n);
}
async function ensureAssetBalanceConditions(account, assetIds, validationType, algod) {
    const accountAddress = transaction.getSenderAddress(account);
    const accountInfo = await algod.accountInformation(accountAddress).do();
    const assetPromises = assetIds.map(async (assetId) => {
        if (validationType === ValidationType.OptIn) {
            if (accountInfo.assets.find((a) => a['asset-id'] === assetId)) {
                config.Config.logger.debug(`Account ${accountAddress} has already opted-in to asset ${assetId}`);
                return assetId;
            }
        }
        else if (validationType === ValidationType.OptOut) {
            try {
                const accountAssetInfo = await algod.accountAssetInformation(accountAddress, assetId).do();
                if (accountAssetInfo['asset-holding']['amount'] !== 0) {
                    config.Config.logger.debug(`Asset ${assetId} is not with zero balance`);
                    return assetId;
                }
            }
            catch (e) {
                config.Config.logger.debug(`Account ${accountAddress} does not have asset ${assetId}`);
                return assetId;
            }
        }
        return null;
    });
    const invalidAssets = (await Promise.all(assetPromises)).filter((assetId) => assetId !== null);
    if (invalidAssets.length > 0) {
        let errorMessage = '';
        if (validationType === ValidationType.OptIn) {
            errorMessage = `Asset${invalidAssets.length === 1 ? '' : 's'} ${invalidAssets.join(', ')} cannot be opted in. Ensure that they are valid and that the account has not previously opted into them.`;
        }
        else if (validationType === ValidationType.OptOut) {
            errorMessage = `Asset${invalidAssets.length === 1 ? '' : 's'} ${invalidAssets.join(', ')} cannot be opted out. Ensure that they are valid and that the account has previously opted into them and holds zero balance.`;
        }
        throw new Error(errorMessage);
    }
}
/**
 * Create an Algorand Standard Asset (ASA).
 * @param create The asset creation definition
 * @param algod An algod client
 * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)
 *
 * @example Usage example
 * ```typescript
 * await algokit.createAsset({ creator: account, total: 1, decimals: 0, name: 'My asset' }, algod)
 * ```
 */
async function createAsset(create, algod) {
    const { creator, total, decimals, name, unit, url, metadataHash, manager, reserveAccount, freezeAccount, clawbackAccount, frozenByDefault, note, transactionParams, lease, ...sendParams } = create;
    const transaction$1 = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({
        from: transaction.getSenderAddress(creator),
        total,
        decimals,
        assetName: name,
        unitName: unit,
        assetURL: url,
        defaultFrozen: frozenByDefault ?? false,
        assetMetadataHash: metadataHash,
        manager: manager ? transaction.getSenderAddress(manager) : undefined,
        reserve: reserveAccount ? transaction.getSenderAddress(reserveAccount) : undefined,
        freeze: freezeAccount ? transaction.getSenderAddress(freezeAccount) : undefined,
        clawback: clawbackAccount ? transaction.getSenderAddress(clawbackAccount) : undefined,
        rekeyTo: undefined,
        suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
        note: transaction.encodeTransactionNote(note),
    });
    const encodedLease = transaction.encodeLease(lease);
    if (encodedLease) {
        transaction$1.addLease(encodedLease);
    }
    const result = await transaction.sendTransaction({ transaction: transaction$1, from: creator, sendParams }, algod);
    if (!sendParams.skipSending) {
        config.Config.getLogger(sendParams.suppressLog).info(`Successfully created asset ${name ? `${name} ` : ''}${unit ? `(${unit}) ` : ''} with ${total} units and ${decimals} decimals via transaction ${transaction$1.txID()} with asset index ${result.confirmation?.assetIndex} and creator ${transaction.getSenderAddress(creator)}.`);
        return result;
    }
    return { transaction: result.transaction };
}
/**
 * Opt-in an account to an asset.
 * @param optIn The opt-in definition
 * @param algod An algod client
 * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)
 *
 * @example Usage example
 * ```typescript
 * await algokit.assetOptIn({ account, assetId }, algod)
 * ```
 */
async function assetOptIn(optIn, algod) {
    const { account, assetId, note, transactionParams, lease, ...sendParams } = optIn;
    const transaction$1 = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: transaction.getSenderAddress(account),
        to: transaction.getSenderAddress(account),
        assetIndex: assetId,
        amount: 0,
        rekeyTo: undefined,
        revocationTarget: undefined,
        closeRemainderTo: undefined,
        suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
        note: transaction.encodeTransactionNote(note),
    });
    const encodedLease = transaction.encodeLease(lease);
    if (encodedLease) {
        transaction$1.addLease(encodedLease);
    }
    if (!sendParams.skipSending) {
        config.Config.getLogger(sendParams.suppressLog).debug(`Opted-in ${transaction.getSenderAddress(account)} to asset ${assetId}`);
    }
    return transaction.sendTransaction({ transaction: transaction$1, from: account, sendParams }, algod);
}
/**
 * Opt-out an account from an asset.
 * @param optOut The opt-in definition
 * @param algod An algod client
 * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)
 *
 * @example Usage example
 * ```typescript
 * await algokit.assetOptOut({ account, assetId, assetCreatorAddress }, algod)
 * ```
 */
async function assetOptOut(optOut, algod) {
    const { account, assetId, note, transactionParams, lease, assetCreatorAddress: _assetCreatorAddress, ensureZeroBalance, ...sendParams } = optOut;
    if (ensureZeroBalance === undefined || ensureZeroBalance) {
        await ensureAssetBalanceConditions(account, [assetId], ValidationType.OptOut, algod);
    }
    const assetCreatorAddress = _assetCreatorAddress ?? (await algod.getAssetByID(assetId).do()).params.creator;
    const transaction$1 = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: transaction.getSenderAddress(account),
        to: transaction.getSenderAddress(account),
        assetIndex: assetId,
        amount: 0,
        rekeyTo: undefined,
        revocationTarget: undefined,
        closeRemainderTo: assetCreatorAddress,
        suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
        note: transaction.encodeTransactionNote(note),
    });
    const encodedLease = transaction.encodeLease(lease);
    if (encodedLease) {
        transaction$1.addLease(encodedLease);
    }
    if (!sendParams.skipSending) {
        config.Config.getLogger(sendParams.suppressLog).debug(`Opted-out ${transaction.getSenderAddress(account)} from asset ${assetId}`);
    }
    return transaction.sendTransaction({ transaction: transaction$1, from: account, sendParams }, algod);
}
/**
 * Opt in to a list of assets on the Algorand blockchain.
 *
 * @param optIn - The bulk opt-in request.
 * @param algod - An instance of the Algodv2 class from the `algosdk` library.
 * @returns A record object where the keys are the asset IDs and the values are the corresponding transaction IDs for successful opt-ins.
 * @throws If there is an error during the opt-in process.
 * @example algokit.bulkOptIn({ account: account, assetIds: [12345, 67890] }, algod)
 */
async function assetBulkOptIn(optIn, algod) {
    const { account, assetIds, validateBalances, transactionParams, note, maxFee, suppressLog } = optIn;
    const result = {};
    if (validateBalances === undefined || validateBalances) {
        await ensureAssetBalanceConditions(account, assetIds, ValidationType.OptIn, algod);
    }
    const suggestedParams = await transaction.getTransactionParams(transactionParams, algod);
    for (const assetGroup of chunks(assetIds, transaction.MAX_TRANSACTION_GROUP_SIZE)) {
        try {
            const transactionsToSign = await Promise.all(assetGroup.map(async (assetId) => ({
                transaction: (await assetOptIn({
                    account,
                    assetId,
                    transactionParams: suggestedParams,
                    note,
                    maxFee,
                    skipSending: true,
                    suppressLog: true,
                }, algod)).transaction,
                signer: account,
            })));
            const txnGrp = {
                transactions: transactionsToSign,
                signer: account,
                sendParams: {
                    suppressLog: true,
                },
            };
            const sendGroupOfTransactionsResult = await transaction.sendGroupOfTransactions(txnGrp, algod);
            assetGroup.map((assetId, index) => {
                result[assetId] = sendGroupOfTransactionsResult.txIds[index];
                config.Config.getLogger(suppressLog).info(`Successfully opted in ${transaction.getSenderAddress(account)} for asset ${assetId} with transaction ID ${sendGroupOfTransactionsResult.txIds[index]},
          grouped under ${sendGroupOfTransactionsResult.groupId} round ${sendGroupOfTransactionsResult.confirmations?.[0]?.confirmedRound}.`);
            });
        }
        catch (e) {
            throw new Error(`Received error trying to opt in ${e}`);
        }
    }
    return result;
}
/**
 * Opt out of multiple assets in Algorand blockchain.
 *
 * @param optOut The bulk opt-out request.
 * @param algod - An instance of the Algodv2 client used to interact with the Algorand blockchain.
 * @returns A record object containing asset IDs as keys and their corresponding transaction IDs as values.
 * @throws If there is an error during the opt-out process.
 * @example algokit.bulkOptOut({ account: account, assetIds: [12345, 67890] }, algod)
 */
async function assetBulkOptOut(optOut, algod) {
    const { account, validateBalances, transactionParams, note, assetIds, maxFee, suppressLog } = optOut;
    const result = {};
    if (validateBalances === undefined || validateBalances) {
        await ensureAssetBalanceConditions(account, assetIds, ValidationType.OptOut, algod);
    }
    const suggestedParams = await transaction.getTransactionParams(transactionParams, algod);
    const assetDetails = await Promise.all(assetIds.map((assetId) => algod.getAssetByID(assetId).do()));
    for (const assetGroup of chunks(assetDetails, transaction.MAX_TRANSACTION_GROUP_SIZE)) {
        try {
            const transactionToSign = await Promise.all(assetGroup.map(async (asset) => ({
                transaction: (await assetOptOut({
                    account,
                    assetId: asset.index,
                    assetCreatorAddress: asset.params.creator,
                    transactionParams: suggestedParams,
                    note,
                    maxFee,
                    skipSending: true,
                    suppressLog: true,
                }, algod)).transaction,
                signer: account,
            })));
            const txnGrp = {
                transactions: transactionToSign,
                signer: account,
                sendParams: {
                    suppressLog: true,
                },
            };
            const sendGroupOfTransactionsResult = await transaction.sendGroupOfTransactions(txnGrp, algod);
            assetGroup.map((asset, index) => {
                result[asset.index] = sendGroupOfTransactionsResult.txIds[index];
                config.Config.getLogger(suppressLog).info(`Successfully opted out ${transaction.getSenderAddress(account)} from asset ${asset.index} with transaction ID ${sendGroupOfTransactionsResult.txIds[index]},
          grouped under ${sendGroupOfTransactionsResult.groupId} round ${sendGroupOfTransactionsResult.confirmations?.[0]?.confirmedRound}.`);
            });
        }
        catch (e) {
            throw new Error(`Received error trying to opt out ${e}`);
        }
    }
    return result;
}

exports.assetBulkOptIn = assetBulkOptIn;
exports.assetBulkOptOut = assetBulkOptOut;
exports.assetOptIn = assetOptIn;
exports.assetOptOut = assetOptOut;
exports.createAsset = createAsset;
//# sourceMappingURL=asset.js.map
